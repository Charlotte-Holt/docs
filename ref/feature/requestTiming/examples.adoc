
== Examples

=== Slow and hung request threshold configuration
The slow and hung request thresholds are configured by setting the `slowRequestThreshold` and `hungRequestThreshold` attributes within the <requestTiming/> element configuration in the server.xml file. Setting these attributes specifies a single slow and hung request threshold for all requests that are timed. You can also set different slow and hung request thresholds for different types of requests. An embedded `<servletTiming/>` or `<jdbcTiming/>` element configuration in the server.xml file overrides the configured slow and hung request thresholds that are defined in the <requestTiming/> element. A <servletTiming/> element configuration can set the slow and hung request threshold by application name, servlet name, or both. A <jdbcTiming/> element configuration can set the slow and hung request threshold by datasource name, sql string, or both. In both cases, the names are taken from the context information for the request, as reported by the https://draft-openlibertyio.mybluemix.net/docs/ref/feature/#eventLogging-1.0.html[Event Logging feature]. The following example shows the <requestTiming/> element configuration with the embedded <servletTiming/> element configuration for one specific servlet and one specific web application:
[source,xml]
----
<requestTiming slowRequestThreshold="10s" hungRequestThreshold="10m">
  <servletTiming servletName="Arm10Servlet" hungRequestThreshold=”20s”/>
  <servletTiming appName="SecurityExchangeApp” hungRequestThreshold=”2h”/>
</requestTiming>
----

=== Slow request detection
When a request runs for longer than it was configured, a warning message is written in the messages log file. Details about the request and events that composed the request are captured. The following example shows the log message for a request that crossed the slow request threshold. The default is 10 seconds:

----
[12/1/14 11:58:09:629 IST] 0000001d com.ibm.ws.request.timing.SlowRequestTimer
W TRAS0112W: Request AABjnS+lIn0_AAAAAAAAAAb has been running on thread 00000021 for at least 10003.571ms.
The following stack trace shows what this thread is currently running.

 	 at java.util.HashMap.getEntry(HashMap.java:516)
	 at java.util.HashMap.get(HashMap.java:504)
	 at org.apache.derby.iapi.store.access.BackingStoreHashtable.get(Unknown Source)
	 at org.apache.derby.impl.sql.execute.HashScanResultSet.getNextRowCore(Unknown Source)
	 at org.apache.derby.impl.sql.execute.NestedLoopJoinResultSet.getNextRowCore(Unknown Source)
	 at org.apache.derby.impl.sql.execute.ProjectRestrictResultSet.getNextRowCore(Unknown Source)
	 at org.apache.derby.impl.sql.execute.DMLWriteResultSet.getNextRowCore(Unknown Source)
	 at org.apache.derby.impl.sql.execute.DeleteResultSet.setup(Unknown Source)
	 at org.apache.derby.impl.sql.execute.DeleteResultSet.open(Unknown Source)
	 at org.apache.derby.impl.sql.GenericPreparedStatement.executeStmt(Unknown Source)
	 at org.apache.derby.impl.sql.GenericPreparedStatement.execute(Unknown Source)
	 at org.apache.derby.impl.jdbc.EmbedStatement.executeStatement(Unknown Source)
	 at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeStatement(Unknown Source)
	 at org.apache.derby.impl.jdbc.EmbedPreparedStatement.executeUpdate(Unknown Source)
	 at com.ibm.ws.rsadapter.jdbc.WSJdbcPreparedStatement.executeUpdate(WSJdbcPreparedStatement.java:626)
	 at com.ibm.websphere.samples.trade.direct.TradeDirect.resetTrade(TradeDirect.java:1832)
	 at com.ibm.websphere.samples.trade.web.TradeConfigServlet.doResetTrade(TradeConfigServlet.java:65)
	 at com.ibm.websphere.samples.trade.web.TradeConfigServlet.service(TradeConfigServlet.java:348)
	 at javax.servlet.http.HttpServlet.service(HttpServlet.java:668)
	 at com.ibm.ws.webcontainer.servlet.ServletWrapper.service(ServletWrapper.java:1275)
	 ....
	 at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1121)
	 at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:614)
	 at java.lang.Thread.run(Thread.java:769)

Duration    Operation
10007.571ms + websphere.servlet.service | TradeWeb | TradeConfigServlet?action=resetTrade
    3.923ms       websphere.datasource.psExecuteUpdate | jdbc/TradeDataSource | delete from holdingejb where holdingejb.account_accountid is null
    0.853ms       websphere.datasource.psExecuteUpdate | jdbc/TradeDataSource | delete from accountprofileejb where userid like 'ru:%'
 5271.341ms +     websphere.datasource.psExecuteUpdate | jdbc/TradeDataSource | delete from orderejb where account_accountid in (select accountid from accountejb a where a.profile_useri like 'ru:%')
----


=== Hung request detection
If the request exceeds the default `hungRequestThreshold` value or the configured threshold value, a warning message is written in the messages log file along with the details about the request. Details about the request and events that compose the request are captured. For a hung request detection, a series of three thread dumps, also known as javacores, is taken with a 1-minute delay between each dump. The following log message example shows the log messages for a request that crossed the hung request detection threshold. The default duration value is 10 minutes. The value that is configured in the following example is 4 min:

----
[WARNING ] TRAS0114W: Request AAA7WlpP7l7_AAAAAAAAAAA was running on thread 00000021 for at least 240001.015ms. The following table shows the events that have run during this request.
Duration       Operation
240001.754ms + websphere.servlet.service | TestWebApp | TestServlet?sleepTime=480000
     0.095ms       websphere.session.setAttribute | mCzBMyzMvAEnjMJJx9zQYIw | userID
     0.007ms       websphere.session.setAttribute | mCzBMyzMvAEnjMJJx9zQYIw | visitCount
----

If a request gets completed after it was detected as hanging initially, a message similar to the following example is logged:

----
TRAS0115W: Request AAA7WlpP7l7_AAAAAAAAAAA
----

If the `interruptHungRequests` value is set to true in the request timing configuration, an attempt is made to interrupt the hung request after the first thread dump has completed. When the server is using an IBM JRE, the classes in the `com.ibm.jvm package`, such as `InterruptibleIOContext` and `InterruptibleLockContext`, are used to interrupt the request. Other methods might be used to interrupt the request depending on what features are configured in the server, and what code the application is executing when the hung request is detected. In most cases, the result of an interrupt is a declared exception that is thrown to the application code that was in control when the hung request was detected. The application can then handle the exception and return an appropriate error to the caller. 
