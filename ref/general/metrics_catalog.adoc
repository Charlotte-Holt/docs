// Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-description: Obtaining metrics data is crucial to effectively monitor the status of your microservice systems. Metrics are emitted from a number of different places. This metrics catalog lists the metrics that can be gathered from applications, the Open Liberty runtime, and the Java virtual machine (JVM).
:seo-title: Metrics catalog
:seo-description: Obtaining metrics data is crucial to effectively monitor the status of your microservice systems. Metrics are emitted from a number of different places. This metrics catalog lists the metrics that can be gathered from applications, the Open Liberty runtime, and the Java virtual machine (JVM).
:page-layout: general-reference
:page-type: general
= Metrics catalog

Obtaining metrics data is crucial to effectively monitor the status of your microservice systems. Metrics are emitted from a number of different places. You can obtain them from applications, the Open Liberty runtime, and the Java virtual machine (JVM). They can be gathered and stored in database tools, such as link:https://prometheus.io/[Prometheus], and displayed on dashboards, such as link:https://grafana.com/[Grafana]. For more information about building observability into your applications, see link:/docs/ref/general/#microservice_observability_metrics.html[Microservice observability with metrics].

Some metrics are always implemented, regardless of any specific platform or runtime. Vendor metrics are metrics that are offered by a specific platform or runtime. The following table lists all Open Liberty metrics:

[caption=]
.An asterisk (`*`) indicates that the metric is specific to Open Liberty. Enable the feature:monitor-1.0[] feature to gather this metric data. A caret (`^`) indicates that the metric is available when you use fault tolerance annotations.
[%header,cols="9,3,3,9"]
|===

|Name
|Type
|Unit
|Description

|classloader.loadedClasses.count
|Gauge
|None
|The number of classes that are currently loaded in the JVM.

|classloader.loadedClasses.total
|Counter
|None
|The total number of classes that were loaded since the JVM started.

|classloader.unloadedClasses.total
|Counter
|None
|The total number of classes that were unloaded since the JVM started.

|connectionpool.connectionHandles{datasource=%s} `*`
|Gauge
|None
|The number of connections that are in use. This number might include multiple connections that are shared from a single managed connection.

|connectionpool.create.total{datasource=%s} `*`
|Counter
|None
|The total number of managed connections that were created since the pool creation.

|connectionpool.destroy.total{datasource=%s} `*`
|Counter
|None
|The total number of managed connections that were destroyed since the pool creation.

|connectionpool.freeConnections{datasource=%s} `*`
|Gauge
|None
|The number of managed connections in the free pool.

|connectionPool.inUseTime.total{datasource=%s} `*`
|Gauge
|Milliseconds
|The total time that all connections are in-use since the start of the server.

|connectionpool.managedConnections{datasource=%s} `*`
|Gauge
|None
|The current sum of managed connections in the free, shared, and unshared pools.

|connectionpool.queuedRequests.total{datasource=%s} `*`
|Counter
|None
|The total number of connection requests that waited for a connection because of a full connection pool since the start of the server.

|connectionPool.usedConnections.total{datasource=%s} `*`
|Counter
|None
|The total number of connection requests that waited because of a full connection pool or did not wait since the start of the server. Any connections that are currently in use are not included in this total.

|connectionpool.waitTime.total{datasource=%s} `*`
|Gauge
|Milliseconds
|The total wait time on all connection requests since the start of the server.

|cpu.availableProcessors
|Gauge
|None
|The number of processors available to the JVM.

|cpu.processCpuLoad
|Gauge
|Percent
|The recent CPU usage for the JVM process.

|cpu.systemLoadAverage
|Gauge
|None
|The system load average for the last minute. If the system load average is not available, a negative value is displayed.

|ft.<name>.bulkhead.callsAccepted.total `^`
|Counter
|None
|The number of calls accepted by the bulkhead.

|ft.<name>.bulkhead.callsRejected.total `^`
|Counter
|None
|The number of calls rejected by the bulkhead.

|ft.<name>.bulkhead.concurrentExecutions `^`
|Gauge<long>
|None
|The number of currently running executions.

|ft.<name>.bulkhead.executionDuration `^`
|Histogram
|Nanoseconds
|A histogram of the time that method executions spend holding a semaphore permit or using one of the threads from the thread pool.

|ft.<name>.bulkhead.waiting.duration `^`
|Histogram
|Nanoseconds
|A histogram of the time that method executions spend waiting in the queue.

|ft.<name>.bulkhead.waitingQueue.population `^`
|Gauge<long>
|None
|The number of executions currently waiting in the queue.

|ft.<name>.circuitbreaker.callsFailed.total `^`
|Counter
|None
|The number of calls that ran and were considered a failure by the circuit breaker.

|ft.<name>.circuitbreaker.callsPrevented.total `^`
|Counter
|None
|The number of calls that the circuit breaker prevented from running.

|ft.<name>.circuitbreaker.callsSucceeded.total `^`
|Counter
|None
|The number of calls that ran and were considered a success by the circuit breaker.

|ft.<name>.circuitbreaker.closed.total `^`
|Gauge<long>
|Nanoseconds
|The amount of time that the circuit breaker spent in closed state.

|ft.<name>.circuitbreaker.halfOpen.total `^`
|Gauge<long>
|Nanoseconds
|The amount of time that the circuit breaker spent in half-open state.

|ft.<name>.circuitbreaker.open.total `^`
|Gauge<long>
|Nanoseconds
|The amount of time that the circuit breaker spent in open state.

|ft.<name>.circuitbreaker.opened.total `^`
|Counter
|None
|The number of times that the circuit breaker moved from closed state to open state.

|ft.<name>.fallback.calls.total `^`
|Counter
|None
|The number of times the fallback handler or method was called.

|ft.<name>.invocations.failed.total `^`
|Counter
|None
|The number of times that a method was called and threw a link:/docs/ref/javadocs/microprofile-1.3-javadoc/org/eclipse/microprofile/faulttolerance/exceptions/FaultToleranceDefinitionException.html[`Throwable`] exception after all fault tolerance actions were processed.

|ft.<name>.invocations.total `^`
|Counter
|None
|The number of times the method was called.

|ft.<name>.retry.callsFailed.total `^`
|Counter
|None
|The number of times the method was called and ultimately failed after retrying.

|ft.<name>.retry.callsSucceededNotRetried.total `^`
|Counter
|None
|The number of times the method was called and succeeded without retrying.

|ft.<name>.retry.callsSucceededRetried.total `^`
|Counter
|None
|The number of times the method was called and succeeded after retrying at least once.

|ft.<name>.retry.retries.total `^`
|Counter
|None
|The number of times the method was retried.

|ft.<name>.timeout.callsNotTimedOut.total `^`
|Counter
|None
|The number of times the method completed without timing out.

|ft.<name>.timeout.callsTimedOut.total `^`
|Counter
|None
|The number of times the method timed out.

|ft.<name>.timeout.executionDuration `^`
|Histogram
|Nanoseconds
|A histogram of the execution time for the method.

|gc.time{type=%s}
|Gauge
|Milliseconds
|The approximate accumulated garbage collection elapsed time. This metric is -1 if the garbage collection elapsed time is undefined for this collector.

|gc.total{type=%s}
|Counter
|None
|The number of garbage collections that occurred. This metric is -1 if the garbage collection count is undefined for this collector.

|jaxws.client.checkedApplicationFaults.total{endpoint=%s} `*`
|Counter
|None
|The number of checked application faults.

|jaxws.client.invocations.total{endpoint=%s} `*`
|Counter
|None
|The number of invocations to this endpoint or operation.

|jaxws.client.logicalRuntimeFaults.total{endpoint=%s} `*`
|Counter
|None
|The number of logical runtime faults.

|jaxws.client.responseTime.total{endpoint=%s} `*`
|Gauge
|Milliseconds
|The total response handling time since the start of the server.

|jaxws.client.runtimeFaults.total{endpoint=%s} `*`
|Counter
|None
|The number of runtime faults.

|jaxws.client.uncheckedApplicationFaults.total{endpoint=%s} `*`
|Counter
|None
|The number of unchecked application faults.

|jaxws.server.checkedApplicationFaults.total{endpoint=%s} `*`
|Counter
|None
|The number of checked application faults.

|jaxws.server.invocations.total{endpoint=%s} `*`
|Counter
|None
|The number of invocations to this endpoint or operation.

|jaxws.server.logicalRuntimeFaults.total{endpoint=%s} `*`
|Counter
|None
|The number of logical runtime faults.

|jaxws.server.responseTime.total{endpoint=%s} `*`
|Gauge
|Milliseconds
|The total response handling time since the start of the server.

|jaxws.server.runtimeFaults.total{endpoint=%s} `*`
|Counter
|None
|The number of runtime faults.

|jaxws.server.uncheckedApplicationFaults.total{endpoint=%s} `*`
|Counter
|None
|The number of unchecked application faults.

|jvm.uptime
|Gauge
|Milliseconds
|The time elapsed since the start of the JVM.

|memory.committedHeap
|Gauge
|Bytes
|The amount of memory that is committed for the JVM to use.

|memory.maxHeap
|Gauge
|Bytes
|The maximum amount of heap memory that can be used for memory management. This metric displays -1 if the maximum heap memory size is undefined. This amount of memory is not guaranteed to be available for memory management if it is greater than the amount of committed memory.

|memory.usedHeap
|Gauge
|Bytes
|The amount of used heap memory.

|servlet.request.total{servlet=%s} `*`
|Counter
|None
|The total number of visits to this servlet since the start of the server.

|servlet.responseTime.total{servlet=%s} `*`
|Gauge
|Nanoseconds
|The total of the servlet response time since the start of the server.

|session.activeSessions{appname=%s} `*`
|Gauge
|None
|The number of concurrently active sessions. A session is considered active if the application server is processing a request that uses that user session.

|session.create.total{appname=%s} `*`
|Counter
|None
|The number of sessions that have logged in since this metric was enabled.

|session.invalidated.total{appname=%s} `*`
|Counter
|None
|The number of sessions that have logged out since this metric was enabled.

|session.invalidatedbyTimeout.total{appname=%s} `*`
|Counter
|None
|The number of sessions that have logged out by timeout since this metric was enabled.

|session.liveSessions{appname=%s} `*`
|Gauge
|None
|The number of users that are currently logged in since this metric was enabled.

|thread.count
|Gauge
|None
|The current number of live threads, including both daemon and non-daemon threads.

|thread.daemon.count
|Gauge
|None
|The current number of live daemon threads.

|thread.max.count
|Gauge
|None
|The peak live thread count since the JVM started or the peak was reset. This includes both daemon and non-daemon threads.

|===

== See also
* Guide: link:/guides/microprofile-metrics.html[Providing metrics from a microservice]
* link:https://github.com/eclipse/microprofile-metrics[MicroProfile Metrics]
* link:https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.0.1/microprofile-fault-tolerance-spec.pdf[MicroProfile Fault Tolerance]
* link:/docs/ref/general/#microservice_observability_metrics.html[Microservice observability with metrics]
