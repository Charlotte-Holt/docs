// Copyright (c) 2018 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//

:page-description: OpenAPI is a standardized mechanism for developers to describe REST APIs  for generating structured documentation in a microservice.
:seo-description: OpenAPI is a standardized mechanism for developers to describe REST APIs  for generating structured documentation in a microservice.

:page-layout: general-reference
:page-type: general
= OpenAPI documentation for microservices


OpenAPI is a standardized mechanism for developers to describe REST APIs  for generating structured documentation in a microservice. With OpenAPI you can describe REST APIs and easily generate API documentation from the APIs themselves. so that other developers can look up how to use your API in their own microservice and enable their microservice to call yours. Alternative you can also write the API doc first and generating the API from the doc.
 MicroProfile OpenAPI is a specification outlined as an official set of annotations and interfaces that help developers successfully generate OpenAPI v3 documentation for their Java RESTful APIs.

You can provide input for the generation of the resulting OpenAPI document in multiple ways.

== Annotations

Using annotations means developers don’t have to re-write the portions of the OpenAPI document that are already covered by the JAX-RS framework (e.g. the HTTP method of an operation). This is the most common path, so definitely check out some of the examples to get familiar with some of these annotations and their generated output.
Because all JAX-RS annotations are processed by default, you can augment the existing code with OpenAPI annotations without needing to rewrite portions of the OpenAPI document that are already covered by the JAX-RS framework.

== Static OpenAPI files

Take the initial output from /openapi as a starting point to document your APIs via Static OpenAPI files. It’s worth mentioning that these static files can also be written before any code, which is an approach often adopted by enterprises that want to lock-in the contract of the API. In this case, we refer to the OpenAPI document as the "source of truth", by which the client and provider must abide.

The MicroProfile Config API externalizes configuration from microservices, keeping it separate from the source code. With MicroProfile Config, external configuration can be injected into services in the containers without repackaging them.

Applications can use MicroProfile Config as a single API to retrieve configuration information from different sources. Configuration data can come from different locations and in different formats – link:/docs/ref/config/[system properties], link:/docs/ref/config/[system environment variables], properties files, XML files, or data sources. In MicroProfile Config, these data sources are called ConfigSources. The same configuration property can be defined in multiple ConfigSources. A prioritization can be used to determine which ConfigSource is used for the property value. Each ConfigSource has a specified priority, which is defined by its ordinal value. A higher ordinal means that the values taken from this ConfigSource override ConfigSources with a lower ordinal value.

== Programming model

Use the API interfaces to provide a bootstrap (or complete) OpenAPI model tree.

table

For a quick overview of annotations, see org.eclipse.microprofile.openapi.annotations package.

When the same annotation is used on a class and a method, the values from the method instance will take precedence for that particular method. This commonly occurs with the @Server and @Tag annotations.

In other cases, such as with @Parameter and @RequestBody, the annotation values from the method’s parameters takes precedence over corresponding annotation values from the method itself - in this scenario the combined usage of these annotations is allowed but discouraged, as it is error prone.

The @Schema annotation has a complex set of possible combinations. It can placed on POJOs (and their fields / methods) and referenced from many other annotations. In the event that a @Schema#implementation value points to a POJO that also contains a @Schema annotation, the values are merged but with precedence given to the referrer annotation (i.e. the one that contains the implementation key). This allows POJO models to be reusable and configurable.

== Static OpenAPI files

Take the initial output from /openapi as a starting point to document your APIs via Static OpenAPI files. The static files can be written before any code, which is an approach often adopted by enterprises that want to lock-in the contract of the API. In this case, we refer to the OpenAPI document as the "source of truth", by which the client and provider must abide.

Depending on the scenario, the document may be fully complete or partially complete. If a document is fully complete then the application developer will want to set the mp.openapi.scan.disable configuration property to true. If a document is partially complete, then the application developer will need to augment the OpenAPI snippet with annotations, programming model, or via the filter.

Vendors are required to fetch a single document named openapi with an extension of yml, yaml or json, inside the application module’s root META-INF folder. If there is more than one document found that matches one of these extensions the behavior of which file is chosen is undefined (i.e. each vendor may implement their own logic), which means that application developers should only place a single openapi document into that folder.

For convenience, you may also place your microprofile-config.properties in the root META-INF folder, if you wish to keep both documents in the same directory. This is in addition to the default locations defined by MicroProfile Config.


== Programming model

Use the API interfaces to provide a bootstrap (or complete) OpenAPI model tree. Application developers are able to provide OpenAPI elements via Java POJOs. The OASFactory is used to create all of the elements of an OpenAPI tree. Vendors are required to call the OASReader a single time, in the order defined by the Processing rules section. Only a single OASReader instance is allowed per application.

The OASModelReader interface allows application developers to bootstrap the OpenAPI model tree used by the processing framework. To use it, simply create an implementation of this interface and register it using the mp.openapi.model.reader configuration key, where the value is the fully qualified name of the reader class. Similar to static files, the model reader can be used to provide either complete or partial model trees. If providing a complete OpenAPI model tree, application developers should set the mp.openapi.scan.disable configuration to true. Oherwise this partial model will be used as the base model during the processing of the other Documentation Mechanisms.


== Filter

Additionally, a Filter is described which can update the OpenAPI model after it has been built from the previously described documentation mechanisms.



There are many scenarios where application developers may wish to update or remove certain elements and fields of the OpenAPI document. This is done via a filter, which is called once after all other documentation mechanisms have completed.

The OASFilter interface allows application developers to receive callbacks for various key OpenAPI elements. The interface has a default implementation for every method, which allows application developers to only override the methods they care about. To use it, simply create an implementation of this interface and register it using the mp.openapi.filter configuration key, where the value is the fully qualified name of the filter class.

Vendors are required to call the registered filter once for each filtered element. For example, the method filterPathItem is called for each corresponding PathItem element in the model tree. This allows application developers to filter the element and any of its descendants.

The order of filter methods called is undefined, with two exceptions:

All filterable descendant elements of a filtered element must be called before its ancestor.

The filterOpenAPI method must be the last method called on a filter (which is just a specialization of the first exception).
