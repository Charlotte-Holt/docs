:page-layout: general-reference
:page-type: general
:page-description: MicroShed testing helps you to write integration tests using testcontainers for Java microservice applications. With MicroShed testing you can test your Open Liberty application from outside the container so you are testing the exact same image that runs in production.
:page-categories: MicroShed testing
:seo-title: Testing in a container with MicroShed testing
:seo-description:  MicroShed testing helps you to write integration tests using testcontainers for Java microservice applications. With MicroShed testing you can test your Open Liberty application from outside the container so you are testing the exact same image that runs in production.
= Testing in a container

Microshed testing is a Java library that helps you write true-to-production integration tests for your microservice applications using link:https://openliberty.io/blog/2019/03/27/integration-testing-with-testcontainers.html[testcontainers].
MicroShed Testing tests your application from outside without accessing it internally.

Integration testing evaluates the performance of a group of microservices as a whole unit, as compared to unit tests, which tests each microservice as an individual unit.
Thus, integration tests are more comprehensive than unit tests.
However, integration tests can be more complicated and take longer to run.
Microshed testing makes your work easier and faster by streamlining integration tests with testcontainers.


== Why integration testing

You need to be sure that your application works in development as well as production mode.
Developers usually run unit tests as they are easier, faster, and test a few methods at a time.
Integration tests assess multiple test classes and components at once, and are better at analyzing the working of the different parts of your application as a whole.
Therefore, developers find integration testing to be more reliable for their application to work in production environment.
However, integration tests take longer and can be complicated to set up and configure.
With faster development cycles and limited time available to developers, it's not always feasible to run integrated tests for your applications.

== Development-production parity

Development-production parity, or dev-prod parity, is one of the factors in the link:https://12factor.net/[twelve-factor app], a methodology to build modern applications.
The idea behind dev-prod parity is to keep the development, staging, and production environments as similar as possible, and it addresses gaps in development ad production in terms of time, personnel, and tools.
Developers mostly use different tools in development as compared to production for speed and ease of use.
For example you might use a local maven build in development, but the application might be deployed to a docker container in production.
Differences between the environments can cause a test to fail in production, even though it passed in development.
The application might work on your machine but not in production.
So it is important to use the same services in development as in production.

== Using Testcontainers

The programming paradigms have changed with how we test software.
Currently, many developers run containers in production.
Containers are convenient and combine everything you need to run a service into a single unit.
They are easy to manage with an orchestration software like Kubernetes.
They are lightweight and disposable and fairly easy to configure with environment variables.
They are easy to leverage containers in a test environment using testcontainers, which is an open source library that supports Junit tests.
Microshed testing is a Java library for Microprofile and Java EE developers to test their applications similar to the production environment.

Using MicroShed Testing, we can write an integration test that looks something like this:

[source, java]
----
@MicroShedTest
public class BasicJAXRSServiceTest {

    // This will search for a Dockerfile in the repository and start up the application
    // in a Docker container, and wait for it to be ready before starting the tests.
    @Container
    public static ApplicationContainer app = new ApplicationContainer()
                    .withAppContextRoot("/myservice");

    // This injects a REST _Client_ proxy of the PersonService shown above
    // This allows us to easily invoke HTTP requests on the running application container
    @RESTClient
    public static PersonService personSvc;

    @Test
    public void testGetPerson() {
        // This invokes an HTTP POST request to the running container, which triggers
        // the PersonService#createPerson endpoint and returns the generated ID
        Long bobId = personSvc.createPerson("Bob", 24);

        // Using the generated ID, invoke an HTTP GET request to read the record we just created
        // The JSON response will be automatically converted to a 'Person' object using JSON-B
        Person bob = personSvc.getPerson(bobId);

        assertEquals("Bob", bob.name);
        assertEquals(24, bob.age);
        assertNotNull(bob.id);
    }

    @Test
    public void testGetUnknownPerson() {
        // This invokes an HTTP GET request to get a person with ID -1, which does not exist
        // asserts that the application container returns an HTTP 404 (not found) exception
        assertThrows(NotFoundException.class, () -> personSvc.getPerson(-1L));
    }

    // ...
}
----

Ready to try using MicroShed Testing to test a MicroProfile or Jakarta EE application? Check out our guide https://openliberty.io/guides/microshed-testing.html[Testing a MicroProfile or Jakarta EE application]
