:page-layout: general-reference
:page-type: general
:page-description: MicroShed testing helps you to write integration tests using testcontainers for Java microservice applications. With MicroShed testing you can test your Open Liberty application from outside the container so you are testing the exact same image that runs in production.
:page-categories: MicroShed testing
:seo-title: Testing in a container with MicroShed testing
:seo-description:  MicroShed testing helps you to write integration tests using testcontainers for Java microservice applications. With MicroShed testing you can test your Open Liberty application from outside the container so you are testing the exact same image that runs in production.
= Testing microservice applications

MicroShed Testing is a Java library that helps you write true-to-production integration tests for your microservice applications with link:https://openliberty.io/blog/2019/03/27/integration-testing-with-testcontainers.html[testcontainers].
link:https://microshed.org/microshed-testing/[MicroShed Testing] library analyzes your application from outside the link:https://www.docker.com/why-docker[Docker] container without accessing the application internally.

Integration tests assess microservices as a group, as compared to unit tests, which test each microservice as an individual unit.
Thus, integration tests are more comprehensive than unit tests.
However, integration tests can be more complicated and take longer to run.
MicroShed Testing library makes your work easier and faster by streamlining integration tests with testcontainers.


== Why integration testing

You need to be sure that your applications works as well in production as it does in the development environment.
Integration tests assess multiple test classes and components, but take longer and can be complicated to set up and configure.
With faster development cycles and limited time available to developers, it's not always feasible to run integrated tests.
Developers often run unit tests instead, because they are easier, faster, and test a few methods at a time, though integration tests analyze your application better.

== Development-production parity

Development-production parity, or dev-prod parity, is one of the factors in the link:https://12factor.net/[twelve-factor app], a methodology to build modern applications.
The idea behind dev-prod parity is to keep the development, staging, and production environments as similar as possible in terms of time, personnel, and tools.
To simplify the development process, developers often use different tools in development than they do in production.
For example, you might use a local maven build in development, but the application might be deployed to a docker container in production.
Differences between the environments can cause a test to fail in production, even though it passed in development.
The application might work on your machine but not in production.
So it is important to use the same services in development as in production.
MicroShed helps achieve dev-prod parity because it tests the application using the same container that is used in production.

== Using MicroShed Testing

Containers are increasingly being used, specifically in a microservices environment.
Currently, many developers run containers in production.
Containers are convenient and combine everything you need to run a service into a single unit.
They are lightweight, disposable, configurable, and easy to manage with an orchestration software like Kubernetes.
It is easy to leverage containers in a test environment using testcontainers, which is an open source library that supports Junit tests.
Microshed testing is a Java library for Microprofile and Java EE developers to test their applications in an environment similar to production.

Using MicroShed Testing, you can write an integration test that looks something like this:

[source, java]
----
@MicroShedTest
public class BasicJAXRSServiceTest {

This will search for a Dockerfile in the repository and start up the application in a Docker container, and wait for it to be ready before starting the tests.

    @Container
    public static ApplicationContainer app = new ApplicationContainer()
                    .withAppContextRoot("/myservice");

This injects a REST _Client_ proxy of the PersonService shown above, which allows us to easily invoke HTTP requests on the running application container

    @RESTClient
    public static PersonService personSvc;

    @Test
    public void testGetPerson() {

This invokes an HTTP POST request to the running container, which triggers the PersonService#createPerson endpoint and returns the generated ID
        Long bobId = personSvc.createPerson("Bob", 24);

  Using the generated ID, invoke an HTTP GET request to read the record we just created. The JSON response will be automatically converted to a 'Person' object using JSON-B
        Person bob = personSvc.getPerson(bobId);

        assertEquals("Bob", bob.name);
        assertEquals(24, bob.age);
        assertNotNull(bob.id);
    }

    @Test
    public void testGetUnknownPerson() {

This invokes an HTTP GET request to get a person with ID -1, which does not exist
         and asserts that the application container returns an HTTP 404 (not found) exception

        assertThrows(NotFoundException.class, () -> personSvc.getPerson(-1L));
    }

   ...
}
----

Ready to try MicroShed Testing to test a MicroProfile or Jakarta EE application? Check out the guide https://openliberty.io/guides/microshed-testing.html[Testing a MicroProfile or Jakarta EE application]
