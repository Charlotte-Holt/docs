// Copyright (c) 2020 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-layout: general-reference
:page-type: general
:seo-title: SSO configuration with JSON Web Tokens - OpenLiberty.io
:seo-description:
= SSO configuration with JSON Web Tokens

JSON Web Tokens (JWT) are used to propagate the user identity that is established by Single sign-on (SSO) between different microservice applications. By configuring SSO user authentication with JWT, you can manage the identity that is shared between applications.

== Enabling identity management with SSO
To propagate user identity across different services with JWT, the identity must first be established with an SSO method. The OpenID Connect (OIDC) standard for authentication provides the framework that enables identity management with SSO. Within this framework, the Social Login SSO method provides a simplified process that estabishes user identity. For more information, see https://draft-openlibertyio.mybluemix.net/docs/ref/general/#oidc.html[Configuring Open Liberty as a single sign-on provider].


== Propagating user identity with JSON Web Tokens
//Provide link to Social Login topic here
After the user identity is established with an SSO method, such as Social Login, you can use JWT to propagate the identity to back-end services. With a signed JWT, you can verify who the user is, when the user requests were made, and any other types of information that the user agreed to you handling, which is called claims. Each consumer of the token can verify that they can trust the claims in it, by verifying that they trust the issuer's signature of the token. After the consumer verifies the signature, they know the content of the token has not been altered since it was created.


== Securing microservices with MicroProfile JSON Web Tokens
The MicroProfile JWT feature provides the standard format that is needed to secure microservices. The JWT format is designed to verify claims between two services. To enable authorization and authentication across different services, the JWT consists of the following sections:

* The header section of the ID token contains information on the type of object and the specific signature algorithm that is used to protect the integrity of the claims in the payload.
* The payload section contains the claims about a user and the authentication event.
* The signature section contains a digital signature based on the payload section of the token and a secret key known to the creator of the JWT.

The following example shows the creation of a signed JWT with Java. The following example shows the creation of a signed JWT with Java. Multiple open source libraries for creating and consuming JWT's exist. Liberty also provides API's to complete those actions in the `Jwt-1.0` feature:
----
import java.security.SignatureException;
import com.google.gson.JsonObject;
import net.oauth.jsontoken.crypto.HmacSHA256Signer;

import net.oauth.jsontoken.SystemClock;
import net.oauth.jsontoken.JsonToken;
import org.joda.time.Duration;
import org.joda.time.Instant;

public class SampleJWTToken {
        private static final Duration SKEW = Duration.standardMinutes(5);

        JsonToken jwtToken = null;
        String[] allPayloadKeys = { "iss", "sub", "aud", "exp", // required
                                    "nbf", "iat", "jti" }; // optional

        public SampleJWTToken(String clientId,
                              String keyId,
                              String signKey,
                              String audience,
                              String subject, // user
                              String jtiId) throws Exception { // InvalidKeyException

                byte[] hs256Key = signKey.getBytes();
                HmacSHA256Signer hmacSha256Signer = new HmacSHA256Signer(
                                clientId, keyId, hs256Key);
                // _rsaSha256Signer = new RsaSHA256Signer(clientId, _keyId,
                //                                        _privateKey);
                SystemClock clock = new SystemClock(SKEW);
                jwtToken = new JsonToken(hmacSha256Signer, clock);
                JsonObject headerObj = jwtToken.getHeader();
                JsonObject payloadObj = jwtToken.getPayloadAsJsonObject();

                headerObj.addProperty("alg", "HS256");

                Instant instantExp = clock.now().plus(600000); // 10 minutes
                jwtToken.setExpiration(instantExp);
                jwtToken.setAudience(audience);
                payloadObj.addProperty("iss", clientId);
                payloadObj.addProperty("sub", subject);

                // optional
                payloadObj.addProperty("jti", jtiId);
                jwtToken.setIssuedAt(clock.now()); // issued at time
        }

        public String getJWTTokenString() throws Exception {
                String signedAndSerializedString = null;
                try {
                        signedAndSerializedString = jwtToken.serializeAndSign();
                } catch (SignatureException e) {
                        throw e;
                }
                return signedAndSerializedString;
        }
}
----
