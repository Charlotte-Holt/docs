// Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:page-description: MicroProfile helps developers to design and impletment cloud-native applications that follow the twelve-factor methodology using microservices.
:seo-title: Designing cloud-native microservices
:seo-description: MicroProfile helps developers to design and impletment cloud-native applications that follow the twelve-factor methodology using microservices.
:page-layout: general-reference
:page-type: general
= Designing cloud-native microservices

Cloud-native is an industry-wide methodology that enables companies to rapidly develop and deploy applications with more flexible scaling options taking full advantage of the power of cloud computing. Cloud-native applications are microservices-oriented, containerized, and dynamically orchestrated to optimize the use of resource. 

Applications built and deployed on cloud-native technology have common characteristics:

- Cloud-native apps adapt microservice architecture where each application is a collection of small services that can be operated independently of each other.
- Microservices are owned by individual development teams which operate autonomously to develop, deploy, scale, and upgrade.
- Cloud-native apps are packaged into containers. Containers provide isolation contexts for microservices. They are highly accessible, scalable, and easily portable from one environment to another, and fast to create or tear-down, which makes them ideal for building and running applications composed of microservices.
- Cloud-native apps are running on developed using continuous delivery model.

How to design cloud-native applications: 

- Follow the twelve-factor application standard methodology.
- Break applications down into smaller chunks as microservices, so that you can easily deploy them independently.
- Use API based design to ensure every service has API so that you can easily communicate with other microservices.
- Use self-service agile infrastructure so that you can scale up or down. 
- Design fault-tolerant applications which is are resilient enough to handle failure making them robust.


== What are Microservices?

Microservices describes an architecture where applications are modularized and split into a set of lightweight, independent services, each built to provide one functionality, that can be developed, deployed, and updated independently without affecting other services in the application. link:/docs/concept/rest_microservices.html[RESTful microservices] communicate with each other using the remote access protocols Representational State Transfer (REST).  
Microservices are independent. Each microservice has its own codebase and is owned by relatively small development team.  It has clear API boundaries which give the team that is developing service flexibility to evolve the implementation. 

Microservices must be resilient. Application stability depends on individual microservices being robust to failure. This is a big difference from traditional architectures, where the supporting infrastructure handles failures for you. Each service needs to apply isolation patterns, such as circuit breakers and bulkheads, to contain failures and define appropriate fallback behaviors to protect upstream services.

Microservices are stateless, transient processes. The state should be stored in external backing cloud services, like Redis, rather than in-memory. Fast startup and graceful shutdown behavior further allow microservices to work well in automated environments that create and destroy instances in response to load or to maintain system health.

== The twelve-factor methodology and why use it?

The best practices for developing cloud-native applications is the twelve-factor application methodology which was drafted by developers at Heroku.  These guidelines are created for building portable, scalable, and resilient applications that thrive in cloud environments (specifically Software as a Service applications). The twelve-factor methodology can be applied to applications written in any programming language and use any combination of backing services (such as database, queue, memory cache, etc.).  

The twelve factors are:

. Codebase – each microservice should have a separate repository so that it can evolve on its own.
. Dependencies – each microservice has its own dependencies declared and libraries are not packaged inside the application.
. Configuration – store configuration in the environment, externalize your configuration. MicroProfile config provides the ability to inject the config properties into the microservices
. Backing services – treat backing services (such as MySQL, Amazon S3, Twitter, etc.) as attached resources.
. Build, release, run – strictly separate build and run stages.
. Processes – treat processes as RESTful API and stateless and share nothing so that they can scale up and down easily without losing data.
. Port binding – export services via port binding, ports should never be hard-coded, and should always be configurable. MicroProfile config provides the ability to inject ports to microservices for chain-up invocations.
. Concurrency – applications use processes independently from each other to scale out allowing for load balancing.
. Disposability – maximize robustness with fast startup and graceful shutdown. Use MicroProfile fault tolerance to make applications more resilient.
. Development/production parity – keep development, staging, and production as similar as possible.
. Logs – treat logs as event streams.
. Admin processes – run admin/management tasks as one-off processes and package alongside the application.

== How does MicroProfile help you create microservices?

link:/docs/intro/microprofile.html[Eclipse MicroProfile] is a set of specifications that was created by an open source community to help developers to write cloud-native Java™ microservices.  MicroProfile has a set of Java APIs that provide easy-to-use interfaces — context dependency injection-based (CDI), programmatic, command-line, and file based. 

MicroProfile provides a way to enable you to create twelve-factor microservices in areas such as configuration, port binding, and disposability. Two of the most important MicroProfile specifications that provides you these  capabilities are MicroProfile config and MicroProfile fault tolerance. 

MicroProfile config can be used to inject config properties into microservices so that changing configuration does not require you to repackage your application. It provides two APIs, one is a programmatic API, and the other is through CDI injection. The CDI injection lets you directly inject either static or dynamic values.  Keep in mind that all the configuration sources are prioritized. If the same property is in multiple configuration sources, then the one with the highest priority will feed into the application. This specification helps you to fulfill the externalizing configuration and port binding requirements in the twelve-factor methodology.

MicroProfile fault tolerance is a solution to build a resilient microservice. It provides a way for microservices to retry during failure, prevent repeated failures, limit microservices to utilize all system resources, timeout when waiting for responses, and fallback resolution after everything fails.  This specification enables you to implement applications that can shut down gracefully when there’s a failure, which is part of the disposability requirement of the twelve-factor methodology.

Using MicroProfile together with Docker and Kubernetes, developers can easily create and manage twelve-factor microservices. 
